# -*- coding: utf-8 -*-
"""Explore Place Recommendation Journie (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eKnbob4-A3HzE-yHMqq2PLuyI6HTW3lK
"""

import warnings
warnings.filterwarnings('ignore')
import numpy as np
import pandas as pd
from sklearn import metrics
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from math import sqrt

rating=pd.read_csv('https://raw.githubusercontent.com/Journie-by-Bangkit-C23-PS462/dataset_tourist/main/tourism_rating.csv')

rating

"""#### group by user"""

placename=pd.read_csv('https://raw.githubusercontent.com/Journie-by-Bangkit-C23-PS462/dataset_tourist/main/tourism_with_id_duration.csv')
placename.sample(1)

rating_merged=pd.merge(rating, placename, how='left', on='Place_Id')
rating_merged.head(5)

placeratings = rating_merged.groupby('User_Id')['Place_Ratings']
placeratings = pd.DataFrame(placeratings.count())
placeratings

train_data, test_data = train_test_split(rating, test_size =.20, random_state=42)


"""# Mean Ratings Predictions"""

class RatingsRecommender():
    def __init__(self, train_data, test_data, user_id, place_id):
        self.train_data = train_data
        self.test_data = test_data
        self.user_id = user_id
        self.place_id = place_id
        
    #Membuat model rekomendasi
    def model_fit(self):
        #Membuat score rekomendasi dari popularitas
        grouped_train = train_data.groupby([self.place_id]).agg({self.user_id: 'count'}).reset_index()
        grouped_train['score']=grouped_train['User_Id']
        grouped_train.drop('User_Id',axis=1,inplace=True)
        #Sorting berdasarkan score
        sorted_train = grouped_train.sort_values(['score', self.place_id], ascending = [0,1])
        #Ranking tempat berdasarkan score
        sorted_train['Rank'] = sorted_train['score'].rank(ascending=False, method='first')
        #Top places
        self.top_places = sorted_train.head(50)

    #Hasil Rekomendasi
    def recommendations(self, user_id, City, n):    
        #Filter hanya place yang dirating user
        ratedPlace = train_data[train_data[self.user_id] == user_id][self.place_id] 
        recom_result = self.top_places[~self.top_places[self.place_id].isin(ratedPlace)]
        recom_result.insert(0,'UserId',user_id)
        recom_result_merged=pd.merge(recom_result, placename, how='left', on='Place_Id')
        recom_result_merged= recom_result_merged.loc[recom_result_merged['City']==City]
        recom_result_merged.drop('Coordinate',axis=1,inplace=True)
        recom_result_merged.drop('Time_Minutes',axis=1,inplace=True)
        recom_result_merged.drop('Duration',axis=1,inplace=True)
        recom_result_merged.drop('UserId',axis=1,inplace=True)
        return recom_result_merged.head(n)
        
    def predictions(self):        
        ratings_mean = pd.DataFrame(train_data.groupby(self.place_id)['Place_Ratings'].mean())
        pred_ratings = []            
        #Membuat prediksi dengan rata-rata rating
        for df in self.test_data.values:
            if(df[1] in (ratings_mean.index)):
                pred_ratings.append(ratings_mean.loc[df[1]])
            else:
                pred_ratings.append(0)
        pred=pd.DataFrame(pred_ratings)
        self.predictions_result=pred
        return pd.DataFrame(pred) 
    
    def eval(self):
        mse = mean_squared_error(self.test_data['Place_Ratings'], self.predictions_result)
        rmse = sqrt(mse)
        return print(f'MSE: {mse}\nRMSE: {rmse}')

result = RatingsRecommender(train_data=train_data, test_data=test_data, user_id='User_Id', place_id='Place_Id')

result.model_fit()

result.predictions()

#result.eval()

def explore(city, n):
    hasil = result.recommendations('1',city ,n = n)
    hasil = hasil.to_dict('records')
    return hasil



